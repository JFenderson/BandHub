generator client {
  provider        = "prisma-client-js"
  output   = "../../../node_modules/.prisma/client"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Band {
  id                 String     @id @default(cuid())
  name               String
  slug               String     @unique
  schoolName         String     @map("school_name")
  city               String
  state              String
  conference         String?
  logoUrl            String?    @map("logo_url")
  bannerUrl          String?    @map("banner_url")
  description        String?
  foundedYear        Int?       @map("founded_year")
  youtubeChannelId   String?    @map("youtube_channel_id")
  youtubePlaylistIds String[]   @map("youtube_playlist_ids")
  lastSyncAt         DateTime?  @map("last_sync_at")
  syncStatus         SyncStatus @default(PENDING) @map("sync_status")
  isActive           Boolean    @default(true) @map("is_active")
  isFeatured         Boolean    @default(false) @map("is_featured")
  featuredOrder      Int?       @map("featured_order")
  featuredSince      DateTime?  @map("featured_since")
  createdAt          DateTime   @default(now()) @map("created_at")
  updatedAt          DateTime   @updatedAt @map("updated_at")
  searchKeywords     String[]   @default([]) @map("search_keywords")
  
  // Sync tracking fields for historical backfill
  firstSyncedAt      DateTime?  @map("first_synced_at")     // When we first synced this band
  earliestVideoDate  DateTime?  @map("earliest_video_date") // Oldest video we have for this band
  latestVideoDate    DateTime?  @map("latest_video_date")   // Newest video we have for this band
  totalVideoCount    Int        @default(0) @map("total_video_count") // Cache of video count
  lastFullSync       DateTime?  @map("last_full_sync")      // Last time we did a complete historical sync
  
  videos             Video[]    @relation("BandVideos")
  opponentVideos     Video[]    @relation("OpponentBandVideos")
  syncJobs           SyncJob[]
  featuredClicks     FeaturedBandClick[]
  followers          FavoriteBand[]
  youtubeVideos      YouTubeVideo[]

  @@index([slug])
  @@index([schoolName])
  @@index([state])
  @@index([conference])
  @@index([isActive, isFeatured])
  @@index([featuredOrder])
  @@index([youtubeChannelId])
  @@map("bands")
}

model ContentCreator {
  id                String    @id @default(cuid())
  
  // Basic Info
  name              String
  youtubeChannelId  String    @unique
  channelUrl        String
  description       String?   @db.Text
  logoUrl           String?   // Custom uploaded logo
  thumbnailUrl      String?   // YouTube channel thumbnail (fallback)
  
  // Stats & Metrics
  subscriberCount   Int       @default(0)
  totalVideoCount   Int       @default(0)
  videosInOurDb     Int       @default(0)
  
  // Quality & Trust Indicators
  isVerified        Boolean   @default(false)
  isFeatured        Boolean   @default(false)
  qualityScore      Int       @default(0) // 0-100
  
  // Sync Tracking
  lastSyncedAt      DateTime?
  firstSyncedAt     DateTime?
  lastFullSync      DateTime?
  
  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relations
  videos            Video[]
  
  @@index([youtubeChannelId])
  @@index([isFeatured])
  @@index([isVerified])
  @@index([qualityScore])
  @@index([createdAt])
  @@map("content_creators")

  // Relations for YouTubeVideo
  youtubeVideos     YouTubeVideo[]
}

// ============ YOUTUBE VIDEO METADATA MODEL ============
// Separate table for storing raw YouTube video metadata before curation
model YouTubeVideo {
  id             String    @id @default(cuid())
  youtubeId      String    @unique @map("youtube_id")
  title          String
  description    String?   @db.Text
  thumbnailUrl   String    @map("thumbnail_url")
  url            String    // Full YouTube URL: https://www.youtube.com/watch?v={videoId}
  duration       Int       @default(0) // Duration in seconds
  publishedAt    DateTime  @map("published_at")
  viewCount      Int       @default(0) @map("view_count")
  likeCount      Int       @default(0) @map("like_count")
  channelId      String    @map("channel_id")
  channelTitle   String?   @map("channel_title")
  
  // Relations - can be linked to band, creator, or both
  bandId         String?   @map("band_id")
  band           Band?     @relation(fields: [bandId], references: [id], onDelete: SetNull)
  creatorId      String?   @map("creator_id")
  creator        ContentCreator? @relation(fields: [creatorId], references: [id], onDelete: SetNull)
  
  // Sync tracking
  syncStatus     SyncStatus @default(PENDING) @map("sync_status")
  lastSyncedAt   DateTime?  @map("last_synced_at")
  syncErrors     String[]   @default([]) @map("sync_errors")
  
  // Metadata
  isPromoted     Boolean   @default(false) @map("is_promoted") // Promoted to main Video table
  promotedAt     DateTime? @map("promoted_at")
  qualityScore   Int       @default(0) @map("quality_score") // 0-100 auto-calculated score
  
  // Timestamps
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  // Indexes for search and filtering
  @@index([bandId])
  @@index([creatorId])
  @@index([publishedAt(sort: Desc)])
  @@index([viewCount(sort: Desc)])
  @@index([bandId, publishedAt(sort: Desc)])
  @@index([creatorId, publishedAt(sort: Desc)])
  @@index([channelId])
  @@index([syncStatus])
  @@index([isPromoted])
  @@index([qualityScore(sort: Desc)])
  @@map("youtube_videos")
}

model Video {
  id             String    @id @default(cuid())
  youtubeId      String    @unique @map("youtube_id")
  title          String
  description    String?
  thumbnailUrl   String    @map("thumbnail_url")
  duration       Int
  publishedAt    DateTime  @map("published_at")
  viewCount      Int       @default(0) @map("view_count")
  likeCount      Int       @default(0) @map("like_count")
  eventName      String?   @map("event_name")
  eventYear      Int?      @map("event_year")
  tags           String[]  @default([])
  isHidden       Boolean   @default(false) @map("is_hidden")
  hideReason     String?   @map("hide_reason")
  qualityScore   Int       @default(0) @map("quality_score")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")
  bandId         String    @map("band_id")
  opponentBandId String?   @map("opponent_band_id")
  categoryId     String?   @map("category_id")
  band           Band      @relation("BandVideos", fields: [bandId], references: [id], onDelete: Cascade)
  category       Category? @relation(fields: [categoryId], references: [id])
  opponentBand   Band?     @relation("OpponentBandVideos", fields: [opponentBandId], references: [id])
  favorites      FavoriteVideo[]
  watchLater     WatchLater[]
  creatorId         String?
  creator           ContentCreator? @relation(fields: [creatorId], references: [id], onDelete: SetNull)

  @@index([bandId])
  @@index([opponentBandId])
  @@index([categoryId])
  @@index([eventYear])
  @@index([publishedAt(sort: Desc)])
  @@index([viewCount(sort: Desc)])
  @@index([isHidden])
  @@index([bandId, categoryId])
  @@index([bandId, eventYear])
  @@index([title])
  @@index([creatorId])
  @@map("videos")
}


model Category {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  description String?
  sortOrder   Int      @default(0) @map("sort_order")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  videos      Video[]

  @@index([slug])
  @@index([sortOrder])
  @@map("categories")
}

model AdminUser {
  id        String   @id @default(uuid())
  email     String   @unique
  passwordHash        String    @map("password_hash")
  name      String
  role      AdminRole   @default(ADMIN)  // Changed from String to AdminRole
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Session tracking fields
  lastLoginAt     DateTime?
  lastLoginIp     String?
  failedLoginAttempts Int @default(0)
  lockedUntil     DateTime?

  // Relations
  auditLogs     AuditLog[]
  refreshTokens RefreshToken[]

  @@map("admin_users")
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique // This will be hashed
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  // Track which device/session this token belongs to
  userAgent String?
  ipAddress String?
  
  // For token family tracking (detect token reuse)
  isRevoked Boolean  @default(false)
  revokedAt DateTime?
  replacedBy String? // ID of the token that replaced this one

  // Relations
  user AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for performance
  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

model AuditLog {
  id          String    @id @default(cuid())
  action      String
  userId      String?   @map("user_id") // Make nullable for system actions
  entityType  String    @map("entity_type")
  entityId    String    @map("entity_id")
  changes     Json?
  ipAddress   String?   @map("ip_address")
  userAgent   String?   @map("user_agent")
  severity    String    @default("info") // info, warning, error, critical
  createdAt   DateTime  @default(now()) @map("created_at")
  user AdminUser? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([entityType, entityId])
  @@index([userId])
  @@index([createdAt(sort: Desc)])
  @@index([action])
  @@index([severity])
  @@map("audit_logs")
}

// JWT Key rotation tracking
model JwtKey {
  id          String    @id @default(cuid())
  keyId       String    @unique @map("key_id") // Key identifier (e.g., "v1", "v2")
  version     Int       @default(1)
  isActive    Boolean   @default(true) @map("is_active")
  isPrimary   Boolean   @default(false) @map("is_primary") // Current signing key
  createdAt   DateTime  @default(now()) @map("created_at")
  expiresAt   DateTime? @map("expires_at")
  rotatedAt   DateTime? @map("rotated_at")

  @@index([isActive])
  @@index([isPrimary])
  @@map("jwt_keys")
}

model SyncJob {
  id            String        @id @default(cuid())
  bandId        String?       @map("band_id")
  jobType       SyncJobType   @map("job_type")
  status        SyncJobStatus @default(QUEUED)
  videosFound   Int           @default(0) @map("videos_found")
  videosAdded   Int           @default(0) @map("videos_added")
  videosUpdated Int           @default(0) @map("videos_updated")
  errors        String[]      @default([])
  startedAt     DateTime?     @map("started_at")
  completedAt   DateTime?     @map("completed_at")
  createdAt     DateTime      @default(now()) @map("created_at")
  
  // Sync parameters for historical backfill
  publishedAfter  DateTime?   @map("published_after")
  publishedBefore DateTime?   @map("published_before")
  maxVideos       Int?        @map("max_videos")
  
  // Quota tracking
  quotaUsed       Int         @default(0) @map("quota_used")
  errorMessage    String?     @map("error_message")
  
  band          Band?         @relation(fields: [bandId], references: [id], onDelete: SetNull)

  @@index([bandId])
  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@index([bandId, status])
  @@map("sync_jobs")
}

model ApiKey {
  id                    String    @id @default(cuid())
  key                   String    @unique
  name                  String
  description           String?
  isActive              Boolean   @default(true) @map("is_active")
  expiresAt             DateTime? @map("expires_at")
  lastUsedAt            DateTime? @map("last_used_at")
  lastRotatedAt         DateTime? @map("last_rotated_at")
  rotationWarningsSent  Int       @default(0) @map("rotation_warnings_sent")
  usageCount            Int       @default(0) @map("usage_count")
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")

  @@index([key])
  @@index([isActive])
  @@index([expiresAt])
  @@map("api_keys")
}

// ============ PUBLIC USER MODELS ============

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String    @map("password_hash")
  name          String
  avatar        String?
  bio           String?
  emailVerified Boolean   @default(false) @map("email_verified")
  preferences   Json      @default("{}")
  lastSeenAt    DateTime? @map("last_seen_at")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  emailVerificationTokens EmailVerificationToken[]
  passwordResetTokens     PasswordResetToken[]
  sessions                UserSession[]
  favoriteVideos          FavoriteVideo[]
  favoriteBands           FavoriteBand[]
  watchLater              WatchLater[]
  notifications           Notification[]
  notificationPreferences NotificationPreference?

  @@index([email])
  @@map("users")
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([token])
  @@index([userId])
  @@map("email_verification_tokens")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime @map("expires_at")
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")

  @@index([token])
  @@index([userId])
  @@map("password_reset_tokens")
}

model UserSession {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token        String   @unique
  deviceType   String?  @map("device_type")
  browser      String?
  ipAddress    String?  @map("ip_address")
  lastActiveAt DateTime @default(now()) @map("last_active_at")
  createdAt    DateTime @default(now()) @map("created_at")
  expiresAt    DateTime @map("expires_at")

  @@index([userId])
  @@index([token])
  @@map("user_sessions")
}

enum SyncStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum AdminRole {
  SUPER_ADMIN
  ADMIN
  MODERATOR
}

enum SyncJobType {
  FULL_SYNC
  INCREMENTAL_SYNC
  SINGLE_VIDEO
  CHANNEL_SYNC
}

enum SyncJobStatus {
  QUEUED
  IN_PROGRESS
  COMPLETED
  FAILED
}

model SearchLog {
  id            String   @id @default(cuid())
  query         String
  resultsCount  Int      @map("results_count")
  filters       Json?
  userId        String?  @map("user_id")
  sessionId     String?  @map("session_id")
  createdAt     DateTime @default(now()) @map("created_at")

  @@index([query])
  @@index([createdAt(sort: Desc)])
  @@index([userId])
  @@map("search_logs")
}

model FeaturedBandClick {
  id          String   @id @default(cuid())
  bandId      String   @map("band_id")
  band        Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  clickedAt   DateTime @default(now()) @map("clicked_at")
  sessionId   String?  @map("session_id")

  @@index([bandId])
  @@index([clickedAt])
  @@map("featured_band_clicks")
}

// ============ FAVORITES AND BOOKMARKS MODELS ============

model FavoriteVideo {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  videoId   String   @map("video_id")
  notes     String?  @db.Text
  createdAt DateTime @default(now()) @map("created_at")
  
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  video Video @relation(fields: [videoId], references: [id], onDelete: Cascade)
  
  @@unique([userId, videoId])
  @@index([userId])
  @@index([videoId])
  @@map("favorite_videos")
}

model FavoriteBand {
  id                   String   @id @default(cuid())
  userId               String   @map("user_id")
  bandId               String   @map("band_id")
  notificationsEnabled Boolean  @default(true) @map("notifications_enabled")
  createdAt            DateTime @default(now()) @map("created_at")
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  band Band @relation(fields: [bandId], references: [id], onDelete: Cascade)
  
  @@unique([userId, bandId])
  @@index([userId])
  @@index([bandId])
  @@map("favorite_bands")
}

model WatchLater {
  id        String    @id @default(cuid())
  userId    String    @map("user_id")
  videoId   String    @map("video_id")
  watched   Boolean   @default(false)
  watchedAt DateTime? @map("watched_at")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  video Video @relation(fields: [videoId], references: [id], onDelete: Cascade)
  
  @@unique([userId, videoId])
  @@index([userId])
  @@index([videoId])
  @@map("watch_later")
}

model Notification {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  type      String   // 'NEW_VIDEO', 'UPCOMING_EVENT', 'WEEKLY_DIGEST'
  title     String
  message   String   @db.Text
  data      Json?    // Additional data (videoId, bandId, etc.)
  read      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, read])
  @@index([createdAt])
  @@map("notifications")
}

model NotificationPreference {
  id                 String   @id @default(cuid())
  userId             String   @unique @map("user_id")
  emailNewVideo      Boolean  @default(true) @map("email_new_video")
  emailUpcoming      Boolean  @default(true) @map("email_upcoming")
  emailWeeklyDigest  Boolean  @default(true) @map("email_weekly_digest")
  inAppNotifications Boolean  @default(true) @map("in_app_notifications")
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("notification_preferences")
}
