generator client {
  provider        = "prisma-client-js"
  output   = "../../../node_modules/.prisma/client"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Band {
  id                 String     @id @default(cuid())
  name               String
  slug               String     @unique
  schoolName         String     @map("school_name")
  city               String
  state              String
  conference         String?
  logoUrl            String?    @map("logo_url")
  bannerUrl          String?    @map("banner_url")
  description        String?
  foundedYear        Int?       @map("founded_year")
  youtubeChannelId   String?    @map("youtube_channel_id")
  youtubePlaylistIds String[]   @map("youtube_playlist_ids")
  lastSyncAt         DateTime?  @map("last_sync_at")
  syncStatus         SyncStatus @default(PENDING) @map("sync_status")
  isActive           Boolean    @default(true) @map("is_active")
  isFeatured         Boolean    @default(false) @map("is_featured")
  featuredOrder      Int?       @map("featured_order")
  featuredSince      DateTime?  @map("featured_since")
  createdAt          DateTime   @default(now()) @map("created_at")
  updatedAt          DateTime   @updatedAt @map("updated_at")
  searchKeywords     String[]   @default([]) @map("search_keywords")
  
  // Sync tracking fields for historical backfill
  firstSyncedAt      DateTime?  @map("first_synced_at")     // When we first synced this band
  earliestVideoDate  DateTime?  @map("earliest_video_date") // Oldest video we have for this band
  latestVideoDate    DateTime?  @map("latest_video_date")   // Newest video we have for this band
  totalVideoCount    Int        @default(0) @map("total_video_count") // Cache of video count
  lastFullSync       DateTime?  @map("last_full_sync")      // Last time we did a complete historical sync
  
  videos             Video[]    @relation("BandVideos")
  opponentVideos     Video[]    @relation("OpponentBandVideos")
  syncJobs           SyncJob[]
  featuredClicks     FeaturedBandClick[]
  followers          FavoriteBand[]
  youtubeVideos      YouTubeVideo[]

  @@index([slug])
  @@index([schoolName])
  @@index([state])
  @@index([conference])
  @@index([isActive, isFeatured])
  @@index([featuredOrder])
  @@index([youtubeChannelId])
  @@map("bands")
}

model ContentCreator {
  id                String    @id @default(cuid())
  
  // Basic Info
  name              String
  youtubeChannelId  String    @unique
  channelUrl        String
  description       String?   @db.Text
  logoUrl           String?   // Custom uploaded logo
  thumbnailUrl      String?   // YouTube channel thumbnail (fallback)
  
  // Stats & Metrics
  subscriberCount   Int       @default(0)
  totalVideoCount   Int       @default(0)
  videosInOurDb     Int       @default(0)
  
  // Quality & Trust Indicators
  isVerified        Boolean   @default(false)
  isFeatured        Boolean   @default(false)
  qualityScore      Int       @default(0) // 0-100
  
  // Sync Tracking
  lastSyncedAt      DateTime?
  firstSyncedAt     DateTime?
  lastFullSync      DateTime?
  
  // Timestamps
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  // Relations
  videos            Video[]
  
  @@index([youtubeChannelId])
  @@index([isFeatured])
  @@index([isVerified])
  @@index([qualityScore])
  @@index([createdAt])
  @@map("content_creators")

  // Relations for YouTubeVideo
  youtubeVideos     YouTubeVideo[]
}

// ============ YOUTUBE VIDEO METADATA MODEL ============
// Separate table for storing raw YouTube video metadata before curation
model YouTubeVideo {
  id             String    @id @default(cuid())
  youtubeId      String    @unique @map("youtube_id")
  title          String
  description    String?   @db.Text
  thumbnailUrl   String    @map("thumbnail_url")
  url            String    // Full YouTube URL: https://www.youtube.com/watch?v={videoId}
  duration       Int       @default(0) // Duration in seconds
  publishedAt    DateTime  @map("published_at")
  viewCount      Int       @default(0) @map("view_count")
  likeCount      Int       @default(0) @map("like_count")
  channelId      String    @map("channel_id")
  channelTitle   String?   @map("channel_title")
  
  // Relations - can be linked to band, creator, or both
  bandId         String?   @map("band_id")
  band           Band?     @relation(fields: [bandId], references: [id], onDelete: SetNull)
  creatorId      String?   @map("creator_id")
  creator        ContentCreator? @relation(fields: [creatorId], references: [id], onDelete: SetNull)
  
  // Sync tracking
  syncStatus     SyncStatus @default(PENDING) @map("sync_status")
  lastSyncedAt   DateTime?  @map("last_synced_at")
  syncErrors     String[]   @default([]) @map("sync_errors")
  
  // Metadata
  isPromoted     Boolean   @default(false) @map("is_promoted") // Promoted to main Video table
  promotedAt     DateTime? @map("promoted_at")
  qualityScore   Int       @default(0) @map("quality_score") // 0-100 auto-calculated score
  
  // Timestamps
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  // Indexes for search and filtering
  @@index([bandId])
  @@index([creatorId])
  @@index([publishedAt(sort: Desc)])
  @@index([viewCount(sort: Desc)])
  @@index([bandId, publishedAt(sort: Desc)])
  @@index([creatorId, publishedAt(sort: Desc)])
  @@index([channelId])
  @@index([syncStatus])
  @@index([isPromoted])
  @@index([qualityScore(sort: Desc)])
  @@map("youtube_videos")
}

model Video {
  id             String    @id @default(cuid())
  youtubeId      String    @unique @map("youtube_id")
  title          String
  description    String?
  thumbnailUrl   String    @map("thumbnail_url")
  duration       Int
  publishedAt    DateTime  @map("published_at")
  viewCount      Int       @default(0) @map("view_count")
  likeCount      Int       @default(0) @map("like_count")
  eventName      String?   @map("event_name")
  eventYear      Int?      @map("event_year")
  tags           String[]  @default([])
  isHidden       Boolean   @default(false) @map("is_hidden")
  hideReason     String?   @map("hide_reason")
  qualityScore   Int       @default(0) @map("quality_score")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")
  bandId         String    @map("band_id")
  opponentBandId String?   @map("opponent_band_id")
  categoryId     String?   @map("category_id")
  band           Band      @relation("BandVideos", fields: [bandId], references: [id], onDelete: Cascade)
  category       Category? @relation(fields: [categoryId], references: [id])
  opponentBand   Band?     @relation("OpponentBandVideos", fields: [opponentBandId], references: [id])
  favorites      FavoriteVideo[]
  watchLater     WatchLater[]
  creatorId         String?
  creator           ContentCreator? @relation(fields: [creatorId], references: [id], onDelete: SetNull)

  @@index([bandId])
  @@index([opponentBandId])
  @@index([categoryId])
  @@index([eventYear])
  @@index([publishedAt(sort: Desc)])
  @@index([viewCount(sort: Desc)])
  @@index([isHidden])
  @@index([bandId, categoryId])
  @@index([bandId, eventYear])
  @@index([title])
  @@index([creatorId])
  @@map("videos")
}


model Category {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  description String?
  sortOrder   Int      @default(0) @map("sort_order")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  videos      Video[]

  @@index([slug])
  @@index([sortOrder])
  @@map("categories")
}

// ============ EVENTS MODEL ============

model Event {
  id           String     @id @default(cuid())
  name         String
  slug         String     @unique
  description  String?    @db.Text
  eventType    EventType  @map("event_type")
  eventDate    DateTime   @map("event_date")
  endDate      DateTime?  @map("end_date")
  location     String?
  venue        String?
  city         String?
  state        String?
  year         Int
  isRecurring  Boolean    @default(false) @map("is_recurring")
  isActive     Boolean    @default(true) @map("is_active")
  imageUrl     String?    @map("image_url")
  createdAt    DateTime   @default(now()) @map("created_at")
  updatedAt    DateTime   @updatedAt @map("updated_at")

  // Relations
  eventVideos  EventVideo[]
  eventBands   EventBand[]

  @@index([slug])
  @@index([eventType])
  @@index([eventDate])
  @@index([year])
  @@index([isActive])
  @@map("events")
}

model EventVideo {
  id        String   @id @default(cuid())
  eventId   String   @map("event_id")
  videoId   String   @map("video_id")
  createdAt DateTime @default(now()) @map("created_at")

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, videoId])
  @@index([eventId])
  @@index([videoId])
  @@map("event_videos")
}

model EventBand {
  id           String   @id @default(cuid())
  eventId      String   @map("event_id")
  bandId       String   @map("band_id")
  role         String?  // e.g., "home", "away", "participant"
  createdAt    DateTime @default(now()) @map("created_at")

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, bandId])
  @@index([eventId])
  @@index([bandId])
  @@map("event_bands")
}

model AdminUser {
  id        String   @id @default(uuid())
  email     String   @unique
  passwordHash        String    @map("password_hash")
  name      String
  role      AdminRole   @default(ADMIN)  // Changed from String to AdminRole
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Session tracking fields
  lastLoginAt     DateTime?
  lastLoginIp     String?
  failedLoginAttempts Int @default(0)
  lockedUntil     DateTime?

  // MFA fields
  mfaEnabled        Boolean   @default(false) @map("mfa_enabled")
  mfaSecret         String?   @map("mfa_secret") // Encrypted TOTP secret
  mfaBackupCodes    String[]  @default([]) @map("mfa_backup_codes") // Hashed backup codes
  mfaEnabledAt      DateTime? @map("mfa_enabled_at")

  // Password policy fields
  passwordChangedAt   DateTime? @map("password_changed_at")
  passwordExpiresAt   DateTime? @map("password_expires_at")
  mustChangePassword  Boolean   @default(false) @map("must_change_password")

  // Session invalidation/versioning for JWTs
  sessionVersion Int @default(0) @map("session_version")

  // Relations
  auditLogs         AuditLog[]
  refreshTokens     RefreshToken[]
  adminSessions     AdminSession[]
  securityEvents    SecurityEvent[]
  passwordHistory   PasswordHistory[]
  magicLinks        MagicLink[]
  oauthAccounts     OAuthAccount[]
  adminPasswordResetTokens AdminPasswordResetToken[]

  @@map("admin_users")
}

model AdminPasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  adminUserId    String   @map("admin_user_id")
  adminUser    AdminUser @relation(fields: [adminUserId], references: [id], onDelete: Cascade)
  expiresAt DateTime @map("expires_at")
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")

  @@index([token])
  @@index([adminUserId])
  @@map("admin_password_reset_tokens")
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique // This will be hashed
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  // Track which device/session this token belongs to
  userAgent         String?
  ipAddress         String?
  deviceFingerprint String?   @map("device_fingerprint") // Device fingerprint hash
  
  // Session association
  sessionId String?  @map("session_id")
  session   AdminSession? @relation(fields: [sessionId], references: [id], onDelete: SetNull)
  
  // For token family tracking (detect token reuse)
  isRevoked     Boolean   @default(false)
  revokedAt     DateTime?
  revokedReason String?   @map("revoked_reason") // 'logout', 'reuse_detected', 'session_expired', 'manual'
  replacedBy    String?   @map("replaced_by") // Hash of the token that replaced this one

  // Relations
  user AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Indexes for performance
  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@index([sessionId])
  @@map("refresh_tokens")
}

// ============ SESSION MANAGEMENT ============

model AdminSession {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  user            AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Session metadata
  ipAddress       String?   @map("ip_address")
  userAgent       String?   @map("user_agent")
  deviceType      String?   @map("device_type") // 'desktop', 'mobile', 'tablet'
  browser         String?
  os              String?
  deviceFingerprint String? @map("device_fingerprint")
  
  // Geolocation (populated via GeoIP lookup)
  country         String?
  region          String?
  city            String?
  latitude        Float?
  longitude       Float?
  
  // Session state
  isActive        Boolean   @default(true) @map("is_active")
  lastActivityAt  DateTime  @default(now()) @map("last_activity_at")
  createdAt       DateTime  @default(now()) @map("created_at")
  expiresAt       DateTime  @map("expires_at")
  revokedAt       DateTime? @map("revoked_at")
  revokedReason   String?   @map("revoked_reason")
  
  // Token chain tracking for reuse detection
  tokenChainId    String?   @map("token_chain_id") // Links tokens in a family
  
  // Relations
  refreshTokens   RefreshToken[]

  @@index([userId])
  @@index([isActive])
  @@index([lastActivityAt(sort: Desc)])
  @@index([tokenChainId])
  @@map("admin_sessions")
}

// ============ SECURITY EVENT LOGGING ============

model SecurityEvent {
  id            String    @id @default(cuid())
  userId        String?   @map("user_id")
  user          AdminUser? @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  // Event details
  eventType     String    @map("event_type") // login_success, login_failed, mfa_enabled, etc.
  severity      String    @default("info") // info, warning, error, critical
  description   String?
  metadata      Json?     // Additional event-specific data
  
  // Request context
  ipAddress     String?   @map("ip_address")
  userAgent     String?   @map("user_agent")
  
  // Geolocation
  country       String?
  region        String?
  city          String?
  latitude      Float?
  longitude     Float?
  
  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")

  @@index([userId])
  @@index([eventType])
  @@index([severity])
  @@index([createdAt(sort: Desc)])
  @@index([ipAddress])
  @@map("security_events")
}

// ============ PASSWORD HISTORY ============

model PasswordHistory {
  id            String    @id @default(cuid())
  userId        String    @map("user_id")
  user          AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)
  passwordHash  String    @map("password_hash") // bcrypt hash of previous password
  createdAt     DateTime  @default(now()) @map("created_at")

  @@index([userId])
  @@index([createdAt(sort: Desc)])
  @@map("password_history")
}

// ============ MAGIC LINKS (PASSWORDLESS AUTH) ============

model MagicLink {
  id            String    @id @default(cuid())
  token         String    @unique // Hashed token
  userId        String    @map("user_id")
  user          AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)
  email         String    // Email the link was sent to
  
  // Link state
  expiresAt     DateTime  @map("expires_at")
  usedAt        DateTime? @map("used_at")
  isUsed        Boolean   @default(false) @map("is_used")
  
  // Request context
  ipAddress     String?   @map("ip_address")
  userAgent     String?   @map("user_agent")
  
  createdAt     DateTime  @default(now()) @map("created_at")

  @@index([token])
  @@index([userId])
  @@index([email])
  @@index([expiresAt])
  @@map("magic_links")
}

// ============ OAUTH ACCOUNTS ============

model OAuthAccount {
  id              String    @id @default(cuid())
  userId          String    @map("user_id")
  user            AdminUser @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // OAuth provider details
  provider        String    // 'google', 'microsoft'
  providerUserId  String    @map("provider_user_id")
  email           String?   // Email from OAuth provider
  displayName     String?   @map("display_name")
  avatarUrl       String?   @map("avatar_url")
  
  // Token storage (encrypted)
  accessToken     String?   @map("access_token")
  refreshToken    String?   @map("refresh_token")
  tokenExpiresAt  DateTime? @map("token_expires_at")
  
  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  @@unique([provider, providerUserId])
  @@index([userId])
  @@index([provider])
  @@map("oauth_accounts")
}

// ============ PASSWORD POLICY CONFIGURATION ============

model PasswordPolicy {
  id                    String   @id @default(cuid())
  name                  String   @default("default")
  
  // Length requirements
  minLength             Int      @default(8) @map("min_length")
  maxLength             Int      @default(128) @map("max_length")
  
  // Complexity requirements
  requireUppercase      Boolean  @default(true) @map("require_uppercase")
  requireLowercase      Boolean  @default(true) @map("require_lowercase")
  requireNumbers        Boolean  @default(true) @map("require_numbers")
  requireSymbols        Boolean  @default(false) @map("require_symbols")
  
  // Expiration and history
  expirationDays        Int      @default(90) @map("expiration_days") // 0 = never expires
  historyCount          Int      @default(5) @map("history_count") // Number of previous passwords to remember
  
  // Account lockout
  maxFailedAttempts     Int      @default(5) @map("max_failed_attempts")
  lockoutDurationMinutes Int     @default(15) @map("lockout_duration_minutes")
  
  // Active flag
  isActive              Boolean  @default(true) @map("is_active")
  
  createdAt             DateTime @default(now()) @map("created_at")
  updatedAt             DateTime @updatedAt @map("updated_at")

  @@map("password_policies")
}

model AuditLog {
  id          String    @id @default(cuid())
  action      String
  userId      String?   @map("user_id") // Make nullable for system actions
  entityType  String    @map("entity_type")
  entityId    String    @map("entity_id")
  changes     Json?
  ipAddress   String?   @map("ip_address")
  userAgent   String?   @map("user_agent")
  severity    String    @default("info") // info, warning, error, critical
  createdAt   DateTime  @default(now()) @map("created_at")
  user AdminUser? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([entityType, entityId])
  @@index([userId])
  @@index([createdAt(sort: Desc)])
  @@index([action])
  @@index([severity])
  @@map("audit_logs")
}

// JWT Key rotation tracking
model JwtKey {
  id          String    @id @default(cuid())
  keyId       String    @unique @map("key_id") // Key identifier (e.g., "v1", "v2")
  version     Int       @default(1)
  isActive    Boolean   @default(true) @map("is_active")
  isPrimary   Boolean   @default(false) @map("is_primary") // Current signing key
  createdAt   DateTime  @default(now()) @map("created_at")
  expiresAt   DateTime? @map("expires_at")
  rotatedAt   DateTime? @map("rotated_at")

  @@index([isActive])
  @@index([isPrimary])
  @@map("jwt_keys")
}

model SyncJob {
  id            String        @id @default(cuid())
  bandId        String?       @map("band_id")
  jobType       SyncJobType   @map("job_type")
  status        SyncJobStatus @default(QUEUED)
  videosFound   Int           @default(0) @map("videos_found")
  videosAdded   Int           @default(0) @map("videos_added")
  videosUpdated Int           @default(0) @map("videos_updated")
  errors        String[]      @default([])
  startedAt     DateTime?     @map("started_at")
  completedAt   DateTime?     @map("completed_at")
  createdAt     DateTime      @default(now()) @map("created_at")
  
  // Sync parameters for historical backfill
  publishedAfter  DateTime?   @map("published_after")
  publishedBefore DateTime?   @map("published_before")
  maxVideos       Int?        @map("max_videos")
  
  // Quota tracking
  quotaUsed       Int         @default(0) @map("quota_used")
  errorMessage    String?     @map("error_message")
  
  band          Band?         @relation(fields: [bandId], references: [id], onDelete: SetNull)

  @@index([bandId])
  @@index([status])
  @@index([createdAt(sort: Desc)])
  @@index([bandId, status])
  @@map("sync_jobs")
}

model ApiKey {
  id                    String    @id @default(cuid())
  key                   String    @unique
  name                  String
  description           String?
  isActive              Boolean   @default(true) @map("is_active")
  expiresAt             DateTime? @map("expires_at")
  lastUsedAt            DateTime? @map("last_used_at")
  lastRotatedAt         DateTime? @map("last_rotated_at")
  rotationWarningsSent  Int       @default(0) @map("rotation_warnings_sent")
  usageCount            Int       @default(0) @map("usage_count")
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")

  @@index([key])
  @@index([isActive])
  @@index([expiresAt])
  @@map("api_keys")
}

// ============ PUBLIC USER MODELS ============

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String    @map("password_hash")
  name          String
  avatar        String?
  bio           String?
  emailVerified Boolean   @default(false) @map("email_verified")
  preferences   Json      @default("{}")
  lastSeenAt    DateTime? @map("last_seen_at")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  emailVerificationTokens EmailVerificationToken[]
  passwordResetTokens     PasswordResetToken[]
  sessions                UserSession[]
  favoriteVideos          FavoriteVideo[]
  favoriteBands           FavoriteBand[]
  watchLater              WatchLater[]
  notifications           Notification[]
  notificationPreferences NotificationPreference?

  @@index([email])
  @@map("users")
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime @map("expires_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@index([token])
  @@index([userId])
  @@map("email_verification_tokens")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime @map("expires_at")
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")

  @@index([token])
  @@index([userId])
  @@map("password_reset_tokens")
}

model UserSession {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token        String   @unique
  deviceType   String?  @map("device_type")
  browser      String?
  ipAddress    String?  @map("ip_address")
  lastActiveAt DateTime @default(now()) @map("last_active_at")
  createdAt    DateTime @default(now()) @map("created_at")
  expiresAt    DateTime @map("expires_at")

  @@index([userId])
  @@index([token])
  @@map("user_sessions")
}

enum SyncStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum AdminRole {
  SUPER_ADMIN
  ADMIN
  MODERATOR
}

enum SyncJobType {
  FULL_SYNC
  INCREMENTAL_SYNC
  SINGLE_VIDEO
  CHANNEL_SYNC
}

enum SyncJobStatus {
  QUEUED
  IN_PROGRESS
  COMPLETED
  FAILED
}

// ============ EVENT ENUMS ============

enum EventType {
  BAYOU_CLASSIC
  SWAC_CHAMPIONSHIP
  HOMECOMING
  BATTLE_OF_THE_BANDS
  FOOTBALL_GAME
  PARADE
  CONCERT
  COMPETITION
  EXHIBITION
  OTHER
}

// ============ SECURITY ENUMS ============

enum SecurityEventType {
  LOGIN_SUCCESS
  LOGIN_FAILED
  LOGOUT
  REFRESH_TOKEN_USED
  REFRESH_REUSE_DETECTED
  MFA_ENABLED
  MFA_DISABLED
  MFA_VERIFIED
  MFA_FAILED
  PASSWORD_CHANGED
  PASSWORD_RESET_REQUESTED
  PASSWORD_RESET_COMPLETED
  MAGIC_LINK_CREATED
  MAGIC_LINK_USED
  OAUTH_LINKED
  OAUTH_UNLINKED
  SESSION_CREATED
  SESSION_REVOKED
  ACCOUNT_LOCKED
  ACCOUNT_UNLOCKED
  SUSPICIOUS_LOGIN
}

enum OAuthProvider {
  GOOGLE
  MICROSOFT
}

model SearchLog {
  id            String   @id @default(cuid())
  query         String
  resultsCount  Int      @map("results_count")
  filters       Json?
  userId        String?  @map("user_id")
  sessionId     String?  @map("session_id")
  createdAt     DateTime @default(now()) @map("created_at")

  @@index([query])
  @@index([createdAt(sort: Desc)])
  @@index([userId])
  @@map("search_logs")
}

model FeaturedBandClick {
  id          String   @id @default(cuid())
  bandId      String   @map("band_id")
  band        Band     @relation(fields: [bandId], references: [id], onDelete: Cascade)
  clickedAt   DateTime @default(now()) @map("clicked_at")
  sessionId   String?  @map("session_id")

  @@index([bandId])
  @@index([clickedAt])
  @@map("featured_band_clicks")
}

// ============ FAVORITES AND BOOKMARKS MODELS ============

model FavoriteVideo {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  videoId   String   @map("video_id")
  notes     String?  @db.Text
  createdAt DateTime @default(now()) @map("created_at")
  
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  video Video @relation(fields: [videoId], references: [id], onDelete: Cascade)
  
  @@unique([userId, videoId])
  @@index([userId])
  @@index([videoId])
  @@map("favorite_videos")
}

model FavoriteBand {
  id                   String   @id @default(cuid())
  userId               String   @map("user_id")
  bandId               String   @map("band_id")
  notificationsEnabled Boolean  @default(true) @map("notifications_enabled")
  createdAt            DateTime @default(now()) @map("created_at")
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  band Band @relation(fields: [bandId], references: [id], onDelete: Cascade)
  
  @@unique([userId, bandId])
  @@index([userId])
  @@index([bandId])
  @@map("favorite_bands")
}

model WatchLater {
  id        String    @id @default(cuid())
  userId    String    @map("user_id")
  videoId   String    @map("video_id")
  watched   Boolean   @default(false)
  watchedAt DateTime? @map("watched_at")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  video Video @relation(fields: [videoId], references: [id], onDelete: Cascade)
  
  @@unique([userId, videoId])
  @@index([userId])
  @@index([videoId])
  @@map("watch_later")
}

model Notification {
  id        String   @id @default(cuid())
  userId    String   @map("user_id")
  type      String   // 'NEW_VIDEO', 'UPCOMING_EVENT', 'WEEKLY_DIGEST'
  title     String
  message   String   @db.Text
  data      Json?    // Additional data (videoId, bandId, etc.)
  read      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, read])
  @@index([createdAt])
  @@map("notifications")
}

model NotificationPreference {
  id                 String   @id @default(cuid())
  userId             String   @unique @map("user_id")
  emailNewVideo      Boolean  @default(true) @map("email_new_video")
  emailUpcoming      Boolean  @default(true) @map("email_upcoming")
  emailWeeklyDigest  Boolean  @default(true) @map("email_weekly_digest")
  inAppNotifications Boolean  @default(true) @map("in_app_notifications")
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("notification_preferences")
}
